# Introduction to assembly

Hello! Welcome to our short series of posts about the [assembly](https://en.wikipedia.org/wiki/Assembly_language) programming language. Most probably you are a software developer like me, interested in low-level programming. If you are a beginner who just started to learn programming, assembly might not be the best place to start. I assume that you're familiar with basic concepts like hexadecimal numbers, a pointer, and boolean logic, have basic knowledge about the command line, and have experience with at least one high-level programming language. Even though neither I nor most likely you use assembly on a daily basis, the information presented in this set of posts still can be highly useful. 

In most cases, we do not write sorting algorithms or string reverse functions manually. Instead, we use high-level programming languages, libraries, and frameworks. Each of us can easily write the simplest code like this:

```C
#include <stdio.h>

int main() {
  int x = 10;
  int y = 100;
  printf("x + y = %d\n", x + y);
  return 0;
}
```

Each of us understands what this C code does. But... how does this code work at low level? What does the compiler do with this code? How does the computer load and execute the resulting program? I think not all of us can answer these questions and they always interested me. I know I can write code using high-level programming languages like Rust, Erlang, Go, etc., but I do not know how it all works at low level. What's happening with my code afterward? 

I learned about assembly at university. I remember I did some basic exercises using something very old like [Turbo Assembler](https://en.wikipedia.org/wiki/Turbo_Assembler). I did these exercises without a deep understanding of what I was doing, copying pieces of code with other students from each other. Many years passed after I graduated from the university. For many years I have been writing code professionally using one or a couple of high-level programming languages and frameworks. But these questions appear in my head more and more often. So I decided to take a few steps back to assembly, and to describe my learning way about the process.

Yes, you may hear the opinion from many engineers that it is useless to a certain degree and it is not so trivial to write better assembly code than one generated by a compiler. That is of course true to a certain degree. 

All my questions were raised from pure curiosity, but some colleagues still use assembly. Here is a short list of active and modern projects where you may find some assembly code:

- [crypto code in openssl](https://github.com/openssl/openssl/tree/master/crypto/sha/asm)
- [ffmpeg codec library](https://github.com/FFmpeg/FFmpeg/tree/master/libavcodec/x86)
- [linux kernel code](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S)
- [Browser engines](https://github.com/mozilla/gecko-dev/tree/master/gfx/cairo/libpixman/src)
- [OpenCV Hardware Acceleration Layer](https://github.com/opencv/opencv/tree/master/modules/core/include/opencv2/core/hal)

So let's start.

## Preparation

Every start needs preparations. This series of posts describes assembly programming for the [x86_64](https://en.wikipedia.org/wiki/X86-64) architecture using the [Linux](https://en.wikipedia.org/wiki/Linux) operating system. That's why you must have a machine with `x86_64` CPU and one [Linux distribution](https://en.wikipedia.org/wiki/Linux_distribution) installed. Besides the machine with Linux, we also need a compiler to compile our assembly code. We mostly will use these two compilers to compile C and assembly examples:

- [GNU gcc](https://gcc.gnu.org/)
- [NASM](https://nasm.us/)

We will use these two tools in most of the examples. If we need something additional, I will mention it in the description of the given example. You can install both `GNU gcc` and `NASM` compilers using a package manager of your Linux distribution. In the case of [Debian](https://www.debian.org/) or [Ubuntu](https://ubuntu.com/), you can use this command to install compilers:

```bash
sudo apt-get install gcc nasm
```

If you use RPM-based distribution, you can install compilers with this command:

```bash
sudo dnf install gcc nasm
```

If you use another Linux distribution, please consult the documentation of your Linux distribution to learn how to install packages.

Last but not least, you will need a text editor where you will write your assembly code. Here I will not advise you anything, as it highly depends on your preferences. I use [GNU Emacs](https://www.gnu.org/software/emacs/) with [nasm-mode](https://github.com/skeeto/nasm-mode). As I said, it is not mandatory and you can use your favorite text editor instead. If you also use Emacs, you can install `nasm-mode` and configure it with:

```elisp
(load "~/.emacs.d/lisp/nasm.el")

(require 'nasm-mode)
(add-to-list 'auto-mode-alist '("\\.\\(asm\\|s\\|S\\)$" . nasm-mode))
```

After you install and configure these tools, we finally can start.

## Basics of NASM assembly syntax

Here we will not see the full syntax of the assembly programming language. We will just see some parts of it very shortly. This chapter's main goal is to build and run our first example without diving too deep into assembly and the `x86_64` CPU architecture. We will start our journey with our favorite and well-known [hello world](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program) program.

Code usually consists of the code itself and comments. In assembly, comments start with the `;` symbol. The code is usually divided into sections (also called memory segments). Each section is used to contain specific data. To implement the `hello world` program, we need only two sections:

-  `data` section
-  `text` section

The `data` section is used to declare static data, for example constants. The data and the size of the `data` section cannot be changed at runtime. The syntax for declaring the `data` section is:

```assembly
section .data
```

Each program that is written on any high-level programming language usually consists of code instructions that says to a computer the steps what to do during execution of a program. An assembly program is not an exception. The `text` section is used to store the instructions of our program. This section must begin with the declaration `global _start`, which tells the operating system kernel where the program execution should [start](https://en.wikipedia.org/wiki/Entry_point) after the program is loaded. The code snippet below shows an example of the declaration of the `text` section and entry point of a program defined with the `_start` symbol:

```assembly
section .text
global _start

_start:
```

Now that we know how to define the basic sections of our first assembly program, we can look at the first instructions. Every NASM assembly source code line contains some combination of the following four fields:

```
[label:] instruction [operands] [; comment]
```

Fields specified in square brackets are optional. A basic `instruction` consists of the following parts:

- Name of the instruction
- Operands of the instruction

If you already have experience with one of the high-level programming languages, you can compare them to a function and its parameters. For example, let's take a look at the following assembly line. Here we can see the instruction `mov` and the operands `count` and `48` used by the instruction:

```assembly
; Put value 48 in the count variable
mov count, 48
```

Now that we know the basics of assembly syntax and structure, let's try to write our first program.

## Hello world

Let's write our first program using assembly based on this code sample:

```assembly
;; Definition of the `data` section
section .data
    ;; String `msg` constant with the value `hello world!`
    msg db      "hello, world!"

;; Definition of the text section
section .text
    ;; Reference to the entry point of our program
    global _start

;; Entry point
_start:
    ;; Number of the system call. The system call number 1 is `sys_write`.
    mov     rax, 1
    ;; The first argument of the `sys_write` system call. Argument number 1 is `stdout`.
    mov     rdi, 1
    ;; The second argument of the `sys_write` system call that contains a reference to the message.
    mov     rsi, msg
    ;; The third argument of the `sys_write` system call that contains the length of the message.
    mov     rdx, 13
    ;; Call the `sys_write` system call.
    syscall
    ;; Number of the system call. The system call number 60 is `sys_exit`.
    mov    rax, 60
    ;; The first argument of the `sys_exit` system call. Argument 0 is successful.
    mov    rdi, 0
    ;; Call the `sys_exit` system call.
    syscall
```

Looks quite long in comparison to the usual well-known `hello world` program. Let's try to figure out what is going on here and how it works.

Take a look first 4 lines of the program. We defined the data section and put there the `msg` constant with the `hello world!` value. Since the constant is defined in the `data` section, it could be used in the code of the program. The next is the declaration of the `text` section and the `_start` entry point of the program. After we will run the program, it will start to execute from the `_start` line.

After both sections are defined, we can move to the actual code of the program. The first four lines start from the `mov` instruction. This instruction expects two operands and uses the value of the second operand in the first one. But what are these `rax`, `rdi`, `rsi`, etc.? We can read in the Wikipedia:

> A central processing unit (CPU) is the hardware within a computer that carries out the instructions of a computer program by performing the basic arithmetical, logical, and input/output operations of the system.

OK, a CPU performs some operations, arithmetics, etc. That we may know without any knowledge about assembly programming. But where does a CPU get data to execute these instructions? The first and the most obvious answer is: from memory. However, reading data from memory and storing data in memory slows down the processor, as it involves complicated processes of sending the data request across the control bus. Thus CPU has its own internal memory storage locations called `registers`. Every `x86_64` CPU has the following so-called **general purpose registers**:

![registers](/content/assets/registers.png)

Each register could be considered as a very small memory slot which may store a value with a size specified in the table above. For example, the `rax` register may contain a value up to `64` bits, the `ax` register may contain a value up to `16` bits and so on. So when we see `mov rax, 1`, this means to put `1` to the `rax` register. Now we have an approximate understanding of what is these `rax`, `rdi`, `rbx` and etc... In the next posts we will find more information about them, for now it is enough to consider them just a small memory slots that a CPU can access in a very fast way. As described above, the name of these registers is `general purpose registers`. Does it mean that we may use any register for any purpose? The simple answer without any details is - no. The [ABI](https://en.wikipedia.org/wiki/Application_binary_interface) and the [calling conventions](https://en.wikipedia.org/wiki/X86_calling_conventions) of an operating system should describe how a certain register is used and why. 

Since these posts are focused on assembly for Linux `x86_64`, the registers have the following meanings:

- `rax` - mostly used as a temporary register to store a temporary value. In the case of a [system call](https://en.wikipedia.org/wiki/System_call), it must contain the number of the system call.
- `rdi` - used to pass the 1st argument to a function.
- `rsi` - used to pass the 2nd argument to a function.
- `rdx` - used to pass the 3rd argument to a function.

There is more details related to the Linux `x86_64` calling conventions but the description above should be enough for now. Knowing the meaning and the way of use of these registers we can return to the code. What do we need to write a `hello world` program? Usually we just pass a `hello world` string to a library function like [printf](https://en.wikipedia.org/wiki/Printf) or so. But these functions usually goes from a [standard library](https://en.wikipedia.org/wiki/Standard_library) of a programming languages we are using. Assembly does not have a standard library. What to do in this case? Well, we have at least the two following approaches:

- Link our assembly program with the C standard library and use [printf](https://man7.org/linux/man-pages/man3/printf.3.html) or any other function that can help us to write a text to the [standard output](https://en.wikipedia.org/wiki/Standard_streams).
- Use the operating system API.

We will go through the second way. Each operating system provides an interface that a user level application may use to interact with the operating system. Usually the functions of this API are called `system calls`. Linux kernel also provides set of system calls to interact with it. The full list of system calls with the respective numbers for the Linux `x86_64` could be found [here](https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl). Looking in this table, we may see:

```
1	common	write			sys_write
```

The information about the given system call could be found in manual pages. To get information about the `sys_write` system_call we can execute the following command in terminal:

```bash
man 2 write
```

The manual page shows the following function:

```C
ssize_t write(int fd, const void buf[.count], size_t count);
```

which is basically a wrapper around the `sys_write` system call provided by the standard C library. Usually the set of arguments of the system call and the wrapper function is the same. So we safely may assume that the `sys_write` system call is defined like that:

```C
size_t sys_write(unsigned int fd, const char *buf, size_t count);
```

The function expects the following three arguments:

*  `fd` - The file descriptor where to write data.
*  `buf` - The pointer to the buffer from which data will be send to the output.
*  `count` - The number of bytes to be written from the buffer to the file specified by the file descriptor from the first argument.

Now we can understand that the first four lines of the assembly code basically do the two following things:

- Specify the number of the system call (the `sys_write` in our example) that we are going to call.
- Specify the arguments of the `sys_write` system call.

Check the system call table we can know that the `sys_write` system call has the number - `1`. Since the `rax` register should contain the number of the system call that we are going to call, we put `1` into it. After this we put `1` to the `rdi` register. That will be the first argument of the `sys_write`. In our case we want to write the `hello world` string in the terminal, so we put `1` which specifies [standard output](https://en.wikipedia.org/wiki/Standard_streams). The next step is to prepare the second argument of the `sys_write` system call. In our case we pass the address of the `msg` constant to the `rsi` register. At the last but not least step we should specify the length of data we want to write. The length of the `hello, world!` string is `13` bytes, so we pass it to the `rdx` register.

As all parameters of the `sys_write` system call is ready, now we can to call the system call itself. It could be done with the `syscall` instruction. That already should print the `hello, world!` string in our terminal. But if you will build and run only these instructions, you will see the [segmentation fault](https://en.wikipedia.org/wiki/Segmentation_fault) error. The problem is that we need to exit properly from the program. To do that, we have to call the `sys_exit` system call. We need to do the same - fill the `rax` with the number of the `sys_exit` system call and fill the respective registers with the parameters needed for this system call. Let's take a look at the system call [table](https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl):

```
60	common	exit			sys_exit
```

We may see that the number of this system call is `60`, so we put this value into the `rax` register. According to the [exit](https://www.man7.org/linux/man-pages/man2/exit.2.html) documentation, this system call expects to get a single argument which is a exit status code. We expect that our program terminates successfully let's just put `0` to the `rdi` register. Our program is ready. Now let's build our program with the following commands:

```bash
nasm -f elf64 -o hello.o hello.asm
ld -o hello hello.o
```

After this we should have an executable file named `hello`. Let's execute it:

```bash
./hello
hello, world!
```

🎉 We have our first assembler program 🎉
